\chapter{Conclusion}
\label{chap:conclusion}
The aims of this project were to create a system to help to build an intuitive understanding of functional programming languages


\section{Strengths}
\subsection{The System is Useful, and Will be Used}
As discussed previously \ref{c4:client}, my client will use this project in future in teaching \hyperref[COMS10016]{COMS10016}. Furthermore, she shared it with a teaching fellow who teaches Haskell at Imperial, who agreed that it is useful. 

\subsection{The Language Achieves Its Design Aims}
See \ref{design:goals} for the initial discussion of the design goals. 

\paragraph{Design Aim 1: `It Should be Simple and Easy to Understand'}
All three focus groups have supported the conclusion that the language is easy to understand. The advanced and intermediate focus groups appreciated the relatively small deviations from Haskell such as the explicit match expressions, and the small set of inbuilts. Indeed, one participant in the intermediate focus group said that they thought the explicit matching syntax was much easier to understand than Haskell's pattern matching, saying it was better for learning \ref{eval:IFG}. The beginner focus group also had little difficulty grasping the syntax and semantics of the language in a lecture context, however they would have found it harder without guidance. Sentiment was more divided about the fact that \sflinline{Cons} is not an infix operator


\paragraph{Design Aim 2: `It Should be Similar to Existing Functional Languages'}
Both the advanced and intermediate focus groups, both with participants that had been formally taught Haskell, had very little trouble understanding the language. 

\paragraph{Design Aim 3: `It Should be Powerful Enough to Explain Key \ac{FP} Concepts'}
Amos Holland used SFL explorer to explain key concepts to the intermediate \ref{eval:IFG} and beginner \ref{eval:BFG} focus groups. 

\begin{quotation}
\noindent `There are features of Haskell it doesn't have, but Haskell is a very advanced language. For teaching functional programming, I think it's got the right range of features'. Amos, During an interview after lecturing in the intermediate focus group
\end{quotation}

\noindent The language is also capable of doing everything that my client mentioned that she wanted to use such a system for (\ref{eval:c1_client}).


\section{Limitations}
\subsection{The Expressions Balloon During Evaluation}
I believe that the languages lack of inbuilts is one of the languages best `features'. However, it is also a curse: as everything is defined with match expressions, the expression balloons vertically with match statements during evaluation. For instance, in the provided `square\_sum' example:

% \begin{figure}[h]
\begin{lstlisting}[language=SFL]
square :: Int -> Int
square x = x * x

// List of the square numbers from lower to upper
list_of_squares :: Int -> Int -> List Int
list_of_squares lower upper = map square $ range lower upper

main :: Int
main = sum $ list_of_squares 1 5
\end{lstlisting}
% \end{figure}

Despite their being no match expressions in sight, the `main' expression balloons to 3 match statements deep within 6 lazy steps:

% \begin{figure}[h]
\begin{lstlisting}[language=SFL]
match (match (match (infiniteFrom 1) {
    | Nil -> Nil
    | Cons x xs -> if ((5 - 1) > 0) (Cons x (take ((5 - 1) - 1) xs)) Nil
}) {
    | Nil -> Nil
    | Cons x xs -> Cons (square x) (map square xs)
}) {
    | Nil -> 0
    | Cons x xs -> (\x. \acc. x + acc) x (foldr (\x. \acc. x + acc) 0 xs)
}
\end{lstlisting}
% \end{figure}

The outer one comes from `sum', the middle one comes from `map', and the inner one comes from `range', all prelude functions. Unfortunately, this is hard to avoid, as pattern matching is a key concept in functional programming languages. Furthermore, a conclusion of the intermediate focus group was that the explicit match syntax, where it was obvious where/how pattern matching was occurring, made understanding pattern matching much easier. Indeed, they agreed that they would have liked to have SFL to learn about pattern matching rather than Haskell (see \ref{eval:IFG}). 

This situation could be improved by being able to select which functions we are interested in seeing the expansion of, and which ones we are not. See \ref{fw:function_checkboxes}

\subsection{There is No Documentation}
When designing the new UI (\ref{c2:next_ui}), I included buttons that would create help menus, and more information about the project, as well as instructions. However, these are time-consuming to write,

\section{Future Work}
\label{conc:future_work}
\paragraph{Add More Documentation to the Website} As the language is quite similar to Haskell, an advanced user would not have much trouble figuring out how the website works. This works fine for a lecture tool as the lecturer would be able to figure it out, the lack of documentation is detrimental to other users. 
\paragraph{Other Evaluation Strategies}
Users could have the option to pick the evaluation strategy (\ref{bg:eval_strategies}). 
\paragraph{Improve Free Choice Mode}
Inspiration could be taken from the UI used by \llessons\ (\ref{bg:llessons_ui}) where the expression to be evaluated could be selected by clicking on the input text itself. 
\paragraph{Selective Skipping}
\label{fw:function_checkboxes}
We are not always interested in all the functions involved in our program. For instance, if a lecturer is attempting to demonstrate \verb|foldr| over a list, they may not be interested in the expansion of how \verb|range| works in order to generate their list they are going to fold over. They may want the evaluation of some things to be `skipped'. 

We could mark certain expressions as uninteresting, and evaluate them as much as we can immediately. For instance, if the syntax for an uninteresting expression looked like `[e]':

\begin{lstlisting}[language=SFL]
main :: Int 
main = sum $ [range 1 4]
\end{lstlisting}

\noindent We could fully evaluate `\lstinline[language=SFL]|range 1 4|' to `\lstinline[language=SFL]|Cons 1 (Cons 2 (Cons 3 Nil))|'. However, this could cause issues if the term does not evaluate. 

% \begin{lstlisting}[language=SFL]
% fix f = f $ fix f

% id x = x

% main = if true 1 [fix id]
% \end{lstlisting}

% The evaluation of `\lstinline[language=SFL]|fix id|' will never terminate. If we were to attempt to evaluate this, it would run forever. If we were to provide a mechanism that forces full evaluation of a term, we would be providing functionality that the user could use to `shoot themselves in the foot'. This would need to be clearly communicated to the user, and a mechanism of stopping this evaluation should be provided if the user judges it has been too long. 



\paragraph{Extensions to the language}
As suggested by Amos during the intermediate focus group (\ref{eval:IFG}) the language could be extended with typeclasses. 
