
\section{Typechecking the Pair Function}
The pair function $\lam{x\;y} (x, y)$ takes two arguments, and returns a pair of the two values. Here, we type check it against its correct type $\alltype{\alpha\;\beta}{\alpha \fto \beta \fto (\alpha, \beta)}$. Type checking/synthesis is done recursively from bottom up, so read [1] upwards. 

\begin{mathpar}
\Gamma = \alpha,\beta,x : \alpha,y : \beta\\
\Delta = \alpha\\


\Infer{\Sub[6]}
  {\Infer{\Var[8]}
      {(x : \alpha) \in \{\Gamma\}}
      {\synjudg{\Gamma}{x}{\alpha}{\Gamma}}
    \\
  \Infer{\SubVar[9]}
      { }
      {\subjudg{\Gamma[\alpha]}{\alpha}{\alpha}{\Gamma[\alpha]}}
  }
  {\chkjudg{\Gamma}{x}{\alpha}{\Gamma}}
\\

\Infer{\Sub[7]}
  {\Infer{\Var[10]}
      {(y : \beta) \in \{\Gamma\}}
      {\synjudg{\Gamma}{y}{\beta}{\Gamma}}
    \\
  \Infer{\SubVar[11]}
      { }
      {\subjudg{\Gamma[\beta]}{\beta}{\beta}{\Gamma[\beta]}}
  }
  {\chkjudg{\Gamma}{y}{\beta}{\Gamma}}

 \Infer{\AllIntro[1]}
   {\Infer{\AllIntro[2]}
   {
    \Infer{\!\ArrIntro[3]}
      {
       \Infer{\!\ArrIntro[4]}
          {
          \Infer{\MyTCRule{\Paircheckrulename}[5]}
            {[6]\chkjudg{\Gamma}{x}{\alpha}{\Gamma} \\ [7]\chkjudg{\Gamma}{y}{\beta}{\Gamma}}
            {\chkjudg{\Gamma}{(x, y)}{(\alpha, \beta)}{\Gamma}}
          }
          {\chkjudg{\alpha,\beta,x : \alpha}{\lam{y} (x, y)}{\beta \fto (\alpha, \beta)}{\Gamma}}
          }
      {{\chkjudg{\alpha,\beta}{\lam{x\; y} (x, y)}{\alpha \fto \beta \fto (\alpha, \beta)}{\Delta, \beta, \{x : \alpha, y : \beta\}}} \\ (= \Gamma)}
   }
   {{\chkjudg{\alpha}{\lam{x\;y} (x, y)}{\alltype{\beta}{\alpha \fto \beta \fto (\alpha, \beta)}}{\{.\}, \alpha, \{.\}}} \\ (= \Delta)}
   }
   {\chkjudg{.}{\lam{x\;y} (x, y)}{\alltype{\alpha\;\beta}{\alpha \fto \beta \fto (\alpha, \beta)}}{.}}\\

   % \Infer{\MyTCRule{\Paircheckrulename[5]}}
   %      {[6]\chkjudg{\Gamma}{x}{\alpha}{\Gamma} \\ [7]\chkjudg{\Gamma}{y}{\beta}{\Gamma}}
   %      {\chkjudg{\Gamma}{(x, y)}{(\alpha, \beta)}{\Gamma}}
   % \Infer{\!\ArrIntro[5]}
   %        {[2]\chkjudg{\alpha,\beta,x : \alpha}{\lam{y} (x, y)}{\beta \fto (\alpha, \beta)}{\Delta, x : \alpha, \Theta}
   %        }
   %        {\chkjudg{\alpha,\beta}{\lam{x\;y} (x, y)}{\alpha \fto \beta \fto (\alpha, \beta)}{\Delta}}

   %   \Infer{\!\ArrIntro[6]}
   %        {[3]\chkjudg{\Gamma}{(x, y)}{(\alpha, \beta)}{\Delta, y : \beta, \Theta}
   %        }
   %        {\chkjudg{\alpha,\beta}{\lam{y} (x, y)}{\beta \fto (\alpha, \beta)}{\Delta}}

    % \Infer{\MyTCRule{\Paircheckrulename[3]}}
    %     {[4]\chkjudg{\Gamma}{x}{\alpha}{\Theta} \\ [5]\chkjudg{\Theta}{y}{\beta}{\Delta}}
    %     {\chkjudg{\Gamma}{(x, y)}{(\alpha, \beta)}{\Delta}}

\end{mathpar}

% \begin{center}\begin{tabular}{ | m{1em} | m{8cm} | m{2cm} | } 
% \hline\textbf{N} & \textbf{Algorithm} & \textbf{Output} \\\hline
% 1 & We do this by adding $\alpha$ to the initially empty context. We then check the function against the type without the $\forall \alpha$: $\alltype{\beta}{\alpha \fto \beta \fto (\alpha, \beta)}$. The output of this checking is then split into 3 parts: everything before the $\alpha$, the $\alpha$ itself, and the bits after the $\alpha$. Our output context is everything before the alpha, which is nothing.  & .

% \\\hline
% \end{tabular}
% \end{center}

\begin{enumerate}
    \item Here, we begin typechecking with the \AllIntro rule to introduce $\forall \alpha$. We do this by adding $\alpha$ to the initially empty context. We then check the function against the type without the $\forall \alpha$: $\alltype{\beta}{\alpha \fto \beta \fto (\alpha, \beta)}$. The output of this checking is then split into 3 parts: everything before the $\alpha$, the $\alpha$ itself, and the bits after the $\alpha$. Our output context is everything in $\Delta$ before the alpha, which is nothing. 
    \item We apply the same rule as above, but we are introducing $\forall \beta$. We then check the function against ${\alpha \fto \beta \fto (\alpha, \beta)}$
    Our output context for this rule is everything in $\Gamma$ before the $\beta$: only $\alpha$.
    \item We then start to unwrap the abstractions. We strip the abstraction over $x$ from the expression, leaving us with ($\lam{y} (x, y)$). We then add $(x:\alpha)$ to our context, and then progress by checking the remaining part of the expression against ${\beta \fto (\alpha, \beta)}$. Our output context is $\Gamma$. 
    \item Same as above, with $y$ against $\beta$. We unwrap the abstraction over $y$ to give us $(x, y)$. We then check this against ${(\alpha, \beta)}$. The output context is $\Gamma$.
    \item We check $(x, y)$ against the type $(\alpha, \beta)$. To check this, we check $x$ against $\alpha$ and $y$ against $\beta$. The output context is $\Gamma$.
    \item To check $x$ against type $\alpha$ we synthesise the type of $x$ ([9]: trivial, as its in the context). We then check this against $\alpha$, and a check of $\alpha$ against $\alpha$ ([10]) trivially passes.
    \item Same as above with $y$ against $\beta$. The output context is $\Gamma$
\end{enumerate}

% \section{Typechecking an Expression Involving Lists}
% We shall attempt to use the algorithm to check the type of $\text{Cons}\;1\;x$ against $Int \fto List\;Int$. This derivation will skip some trivial subtyping/instantiation, but it should serve as a demonstration of how more complex checking works. 

% \begin{mathpar}
% T_{Cons} = \alltype{\alpha}{\alpha \fto List\; \alpha \fto List\;\alpha}\\
% \Gamma_0 = T_{Cons}\and
% \Gamma_1 = \Gamma_0, \ahat, \bhat, x : \ahat \\

% \Infer{\Sub[1]}
%     {
%         [2]
%         \\
%         \subjudg{\Theta}{[\Theta]A}{[\Theta]B}{\Delta}
%     }
%     {\chkjudg{\Gamma}{\lam{x} Cons\;1\;x}{List\;Int}{\Delta}}

% \\

% {\Infer{{\!\ArrIntroSyn}[2]}
%     {
%     \chkjudg{\Gamma_1}{Cons\;1\;x}{\bhat}{\Delta, x : \ahat, \Theta}
%     }
%     {{\synjudg{\Gamma_0}{\lam{x} Cons\;1\;x}{\ahat \arr \bhat}{\Delta}}}

%     \Infer{\!\ArrElim[3]}
%         {
%         {
%             [4]{\synjudg{\Gamma_1}{Cons\,1}{C}{\Delta}}
%         }
%         \\
%         \appjudg{\Gamma_1}{x}{[\Gamma_1]A}{C}{\Delta}
%         }
%         {\synjudg{\Gamma}{Cons\,1\,x}{C}{\Delta}}
% }

% \\
% \Infer{\!\ArrElim[4]}
%     {
%     {
%     \Infer{\Var}
%         {(Cons : T_{Cons}) \in \Gamma_1}
%         {\synjudg{\Gamma_1}{Cons}{T_{Cons}}{\Gamma_1}}
%     }
%     \\
%     {
%      \Infer{\AllApp}
%         {\appjudg{\Gamma_1,\ahat}{1}{(\ahat \fto List\; \ahat \fto List\;\ahat)}{C}{\Delta}}
%         {\appjudg{\Gamma_1}{1}{\alltype{\alpha}{\alpha \fto List\; \alpha \fto List\;\alpha}}{C}{\Delta}}
%     }
%     }
%     {\synjudg{\Gamma_1}{Cons\,1}{C}{\Delta}}
% \end{mathpar}


\section{Typechecking an Expression Involving Lists}
We shall attempt to use the algorithm to check the type of $\text{Cons}\;1\;x$ against $List\;Int$. This derivation should serve as a demonstration of how more complex checking works. This derivation assumes $Cons$ and $Nil$ are defined over $Int$s only. Note that we increment the context number without changing the context, this is to reflect how the \Unionsubrulename rules works by iterating over all of the fields. The reason the context is never changed is as we do not have any abstractions or foralls, so no variables or type variables are introduced.

\begin{mathpar}
T_{Nil} = List\;Int\and
T_{Cons} = {Int \fto List\;Int \fto List\;Int}\\
\Gamma_0 = T_{Cons}, T_{Nil}\and\Gamma_1 = \Gamma_0\and\Gamma_2 = \Gamma_1\\

\\

\Infer{\MyTCRule{\Unionsubrulename}[10]}
    {\Infer{\MyTCRule{\Intsubrulename}[11]}{ }
        {\subjudg{\Gamma_0}{\Inttype}{\Inttype}{\Gamma_1}}}
    {\subjudg{\Gamma_0}{List[Int]}{List[Int]}{\Gamma_{1}}}
\\

\Infer{\ArrApp[7]}
    {     \Infer{\Sub[8]}
          { 
          {
          \Infer{\Var[9]}
            {(Nil : T_{Nil}) \in \Gamma_0}
            {\synjudg{\Gamma_0}{Nil}{T_{Nil}}{\Gamma_0}}
          }
            \\
            [10]\subjudg{\Gamma_0}{List[Int]}{List[Int]}{\Gamma_{1}}
          }
          {\chkjudg{\Gamma}{Nil}{List\;Int}{\Gamma_1}}}
    {\appjudg{\Gamma_0}{Nil}{List\;Int \arr List\;Int}{List\;Int}{\Gamma_1}}

\\
\Infer{\!\ArrElim[3]}
{
{
\Infer{\Var[4]}
    {(Cons : T_{Cons}) \in \Gamma_0}
    {\synjudg{\Gamma_0}{Cons}{T_{Cons}}{\Gamma_0}}
}
\\
    {
    \Infer{\ArrApp[5]}
        {
        \Infer{\MyTCRule{\Intcheckrulename}[6]}
            { }
            {\chkjudg{\Gamma_0}{1}{\Inttype}{\Gamma_0}}
        }
        {\appjudg{\Gamma_0}{1}{T_{Cons}}{List\;Int \arr List\;Int}{\Gamma_1}}
     % \Infer{\AllApp}
     %    {\appjudg{\Gamma_1,\ahat}{1}{(\ahat \fto List\; \ahat \fto List\;\ahat)}{C}{\Delta}}
     %    {\appjudg{\Gamma_1}{1}{\alltype{\alpha}{\alpha \fto List\; \alpha \fto List\;\alpha}}{C}{\Delta}}
    }
    }
    {\synjudg{\Gamma_0}{Cons\,1}{List\;Int \arr List\;Int}{\Gamma_1}}
\\

\Infer{\!\ArrElim[2]}
    {
    {
        [3]{\synjudg{\Gamma_0}{Cons\,1}{List\;Int \arr List\;Int}{\Gamma_1}}
    }
    \\
    [7]\appjudg{\Gamma_0}{Nil}{List\;Int \arr List\;Int}{List\;Int}{\Gamma_1}
    }
    {\synjudg{\Gamma_0}{Cons\,1\,Nil}{List\;Int}{\Gamma_1}}
\\

\Infer{\Sub[1]}
    {
        [2]{\synjudg{\Gamma_0}{Cons\,1\,Nil}{List\;Int}{\Gamma_1}}
        \\
        [10]\subjudg{\Gamma_0}{List[Int]}{List[Int]}{\Gamma_{2}}
    }
    {\chkjudg{\Gamma_0}{Cons\;1\;Nil}{List\;Int}{\Gamma_2}}


\end{mathpar}