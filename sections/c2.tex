\chapter{Cycle 2 - Types and Pattern Matching}
This second cycle was about extending the language with more complicated features. 

\section{Requirements Analysis}
I presented the proof of concept project to my client, who was very positive about the project and its potential. During the meeting, I started by giving my client a demo of the proof of concept. The discussion was informal, a friendly conversation rather than a structured interview, to allow the direction of questioning to change depending on the clients answers. 

\paragraph{What does the client think of the proof of concept language and interface}
I gave a brief demonstration of the evaluation of the following program 

\begin{verbatim}
fac n = if n <= 1 then 1 else n * (fac (n - 1))
main = fac 5
\end{verbatim}
The system froze halfway through the evaluation, but upon a refresh we managed to get through the program. My client had the following thoughts about the language in its proof of concept phase:

\begin{itemize}
    \item She liked that the language looked similar to Haskell. Particularly, she mentioned that she liked the \verb|if _ then _ else| syntax, and the function assignment shorthand syntax (\verb|fac n = ...| rather than \verb|fac = \n. ...|, even though these are identical)
    \item She thought that the factorial function was quite elegant, and believed that it would be understandable to people who did not know Haskell.  
\end{itemize}

She had the following thoughts about the UI in its proof of concepts phase (see \ref{fig:screenshot_cycle_1_end})

\begin{itemize}
    \item She liked the editor, as it felt like the editor she was used to (vs code)
    \item She recognised that the system is a proof of concept, but emphasised the importance of stability in a teaching tool, as it would waste a lot of time if it constantly broke in the lecture. 
    \item She was confused about `laziest' being an option, as she could not tell whether it was referring to one of the other on screen options, or if it was a `hidden' option
    \item She did not like how the redex contraction pairs were represented on the buttons. The vertical bar separating redex from contraction was not obvious enough. On top of this, the bar was not centred so it was hard to look through all of the redexes at once as they were not aligned with each other. 
\end{itemize}

\paragraph{What functional programming language concepts would be the most useful for this system to demonstrate}
\begin{itemize}
    \item Pattern matching
    \item User definable data types that allow for 
    \item List and common list functions such as `map' and `fold'. She says that this is one of the areas that students struggle to grasp most
    \item 
\end{itemize}

\paragraph{What additional language features should I aim to add}
\begin{itemize}
    \item 
\end{itemize}

\paragraph{What additional interface features should I aim to add}
\begin{itemize}
    \item Syntax highlighting, to make the language easier to read
    \item A history of what 
\end{itemize}

\section{Design}

\subsection{Language Changes}
\subsubsection{Type System}
We must have types representing integers and booleans in our language, if we are to effectively represent the type of expression containing their respective literals. We also want our type system to be able to express functions. We also want polymorphism in our type system, as rewriting functions many times for different data types makes programs more verbose. 

Allowing for algebraic user defined data types in a similar manner to Haskell would make the language much more expressive and much more powerful, as well as bringing it closer to Haskell. Supporting tagged unions and tuples in the \ac{SFL} type system would massively increase the ease of writing complex programs. It would also allow for complex data structures such as trees and lists. 

Type names, as well as constructor names, start with uppercase letters in Haskell. This allows them to be easily differentiated from type variables, as well as regular variables. 

First-order polymorphic type constructors would be useful to have in \ac{SFL}, with one example of their utility being defining the polymorphic function "\verb|length :: List a -> Int|" which should work regardless of what type the list is over.

\input{sections/fig_sfl_types}

We can avoid thinking about kinds by enforcing that a type constructor is always given the correct number of arguments



% \begin{syntax}[Types in \ac{SFL}]
% (Inbuilts): \(B::=Int\mid Bool\)\newline
% (Monotype): \(\tau, \sigma ::= \alpha \mid B \mid \tau \rightarrow \sigma \mid (\tau, \sigma) \mid \Alpha \;T, U,...\)\newline
% (Alias): \(A ::= Id = T\)\newline
% (Type): \(T, U ::= \alpha \mid B \mid T \rightarrow U \mid (T, U) \mid \forall a. T \mid \Alpha \;T, U,...\)
% \end{syntax}
Note that our type constructor application definition above is more permissive than is correct, as it does not enforce correct arity. This can be handled by the parser maintaining the context of the arity of each type. It can then be double checked for debugging purposes via an assertion in the type checker. 

\subsubsection{Match}
To support different execution based on a condition, we must have some structure that can differentiate between values \ref{design:values}. 

\subsubsection{Syntax Sugar}

\subsection{UI}
I completely redesigned the UI based on the clients feedback, as well as some other factors. This design was meant to be a work in progress but it looks quite similar to the final release of the product

I discussed this design with the Advanced Focus Group that 
\ref{fig:screenshot_figma1}

\section{Implementation}
\subsection{The Parser}

\subsubsection{The Type Checker}
\input{sections/fig_types_ctx}