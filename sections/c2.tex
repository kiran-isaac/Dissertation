\chapter{Cycle 2 - Types and Pattern Matching}
This second cycle was about extending the language with more complicated features. 

\section{Requirements Analysis}
I presented the proof of concept project to my client, who was very positive about the project and its potential. During the meeting, I started by giving my client a demo of the proof of concept. The discussion was informal, a friendly conversation rather than a structured interview, to allow the direction of questioning to change depending on the clients answers. 

\paragraph{What does the client think of the proof of concept language and interface}
I gave a brief demonstration of the evaluation of the following program 

\begin{verbatim}
fac n = if n <= 1 then 1 else n * (fac (n - 1))
main = fac 5
\end{verbatim}
The system froze halfway through the evaluation, but upon a refresh we managed to get through the program. My client had the following thoughts about the language in its proof of concept phase:

\begin{itemize}
    \item She liked that the language looked similar to Haskell. Particularly, she mentioned that she liked the \verb|if _ then _ else| syntax, and the function assignment shorthand syntax (\verb|fac n = ...| rather than \verb|fac = \n. ...|, even though these are identical)
    \item She thought that the factorial function was quite elegant, and believed that it would be understandable to people who did not know Haskell.  
\end{itemize}

She had the following thoughts about the UI in its proof of concepts phase (see \ref{fig:screenshot_cycle_1_end})

\begin{itemize}
    \item She liked the editor, as it felt like the editor she was used to (vs code)
    \item She recognised that the system is a proof of concept, but emphasised the importance of stability in a teaching tool, as it would waste a lot of time if it constantly broke in the lecture. 
    \item She was confused about `laziest' being an option, as she could not tell whether it was referring to one of the other on screen options, or if it was a `hidden' option
    \item She did not like how the redex contraction pairs were represented on the buttons. The vertical bar separating redex from contraction was not obvious enough. On top of this, the bar was not centred so it was hard to look through all of the redexes at once as they were not aligned with each other. 
\end{itemize}

\paragraph{What functional programming language concepts would be the most useful for this system to demonstrate}
\begin{itemize}
    \item Pattern matching
    \item User definable data types that allow for 
    \item List and common list functions such as `map' and `fold'. She says that this is one of the areas that students struggle to grasp most
    \item 
\end{itemize}

\paragraph{What additional language features should I aim to add}
\begin{itemize}
    \item 
\end{itemize}

\paragraph{What additional interface features should I aim to add}
\begin{itemize}
    \item Syntax highlighting, to make the language easier to read
    \item A history of what 
\end{itemize}

\section{Design}

\subsection{Language Changes}
\subsubsection{Type System}
We must have types representing integers and booleans in our language, if we are to effectively represent the type of expression containing their respective literals. We also want our type system to be able to express functions. We also want polymorphism in our type system, as rewriting functions many times for different data types makes programs more verbose. 

Allowing for algebraic user defined data types in a similar manner to Haskell would make the language much more expressive and much more powerful, as well as bringing it closer to Haskell. Supporting tagged unions and tuples in the \ac{SFL} type system would massively increase the ease of writing complex programs. It would also allow for complex data structures such as trees and lists. 

Type names, as well as constructor names, start with uppercase letters in Haskell. This allows them to be easily differentiated from type variables, as well as regular variables. 

First-order polymorphic type constructors would be useful to have in \ac{SFL}, with one example of their utility being defining the polymorphic function "\verb|length :: List a -> Int|" which should work regardless of what type the list is over.

\input{sections/fig_sfl_types}

We can avoid thinking about kinds by enforcing that a type constructor is always given the correct number of arguments



% \begin{syntax}[Types in \ac{SFL}]
% (Inbuilts): \(B::=Int\mid Bool\)\newline
% (Monotype): \(\tau, \sigma ::= \alpha \mid B \mid \tau \rightarrow \sigma \mid (\tau, \sigma) \mid \Alpha \;T, U,...\)\newline
% (Alias): \(A ::= Id = T\)\newline
% (Type): \(T, U ::= \alpha \mid B \mid T \rightarrow U \mid (T, U) \mid \forall a. T \mid \Alpha \;T, U,...\)
% \end{syntax}
Note that our type constructor application definition above is more permissive than is correct, as it does not enforce correct arity. This can be handled by the parser maintaining the context of the arity of each type. It can then be double checked for debugging purposes via an assertion in the type checker. 

\subsubsection{Match}
To support different execution based on a condition, we must have some structure that can differentiate between values \ref{design:values}. 

\subsubsection{Syntax Sugar}

\subsection{UI}
I completely redesigned the UI based on the clients feedback, as well as some other factors. See \ref{fig:screenshot_cycle_1_end} for the current state. See \ref{fig:screenshot_figma1} and \ref{fig:screenshot_figma2} for screenshots of the new design. 

This design was meant to be a work in progress but it looks quite similar to the final release of the product (Screenshots \ref{fig:screenshot_final_dark}, \ref{fig:screenshot_final_light}, \ref{fig:screenshot_final_dark_prelude_free} and \ref{fig:screenshot_final_light_prelude_free}). Before implementing this design, I discussed this design with the Advanced Focus Group (see \ref{ref:afg_figma}) and they were much more positive about this UI than the existing one 

\section{Implementation}
\subsection{The Parser}

\subsubsection{The Type Checker}
The type checker will be bidirectional, and will follow and algorithm largely based on the one in \cite{completebidir}. The quote that follows is from this paper, and describes bidirectional type checking and its merits:
\begin{quote}
Bidirectional typechecking, in which terms either synthesize a type or are checked against a known type, has become popular for its scalability ..., its error reporting, and its relative ease of implementation.
\end{quote}
\noindent It was the `relative ease of implementation' that attracted me to bidirectional type checking. 

This paper describes an algorithm for bidirectional type checking.

\input{sections/fig_types_ctx}

\section{Types}

Rust allows us to represent our types (see \ref{fig:tc_types} for the definition of the type system), quite easily using Enums. Rust's Enums are an example of algebraic data types, and are therefore very useful for defining our own algebraic data type system. See \ref{fig:type_lst} for the listing. 

\begin{figure}[ht]
    \centering
    \begin{tabular}{c}
    \begin{lstlisting}[language=Rust]
pub enum Primitive {
    Int64,
    Bool,
}

pub enum Type {
    Unit,
    Primitive(Primitive),
    Function(Box<Type>, Box<Type>),
    TypeVariable(String),
    Forall(String, Box<Type>),
    Product(Box<Type>, Box<Type>),
    Union(String, Vec<Type>),
    Alias(String, Box<Type>),

    Existential(usize),
}
    \end{lstlisting}
    \end{tabular}
    \caption{The Rust code listing for the definition of types. Existential is separated as it is more of an implementation detail than a part of the type system}
    \label{fig:type_lst}
\end{figure}

We must use \verb|Box<Type>|, which represents a pointer to a heap allocated object, otherwise it would be impossible to calculate the size of \verb|Type|, as it could be infinitely large with it containing another \verb|Type| recursively. \verb|Box<Type>| however has known size: the size of a pointer in the target architecture. We also define Existential, as an implementation detail needed for the type checker. 

\subsection{Methods on Types}
Below are a selection of the more important or interesting methods implemented on Types.

\paragraph{Substitution of type variables} We may wish to set a type variable to another type. For instance, if given the type expression \(T \; U\) where \(T\) and \(U\) are types, and we know that one of the constructors of \(T\) is of generic type \(\forall a.a \rightarrow T \; a\), the type of the constructor for this type should be \(U \rightarrow T \; U\). We have `instantiated' the type variable \(a\) to be \(U\) by substituting \(a\) with \(U\) throughout the expression, and removing the \(\forall a\). This is required for the type checker. 

\paragraph{To String} We will frequently wish to display types as strings for debugging purposes. 

\section{Evaluation}

\label{ref:afg_figma}