\chapter{Cycle 3 --- Improving the UI/UX}
The main focus of this cycle is to implement the next UI iteration, as well as to improve the language. 

\section{Requirements Analysis}
The motivations for this cycle come mainly from the advanced focus group, however requirements from the \hyperref[sec:c1_autoethnography]{autoethnographic phase} of the project, as well as the \hyperref[eval:c1]{proof of concept client meeting} continue to be relevant. 

The advanced focus group was generally very positive about the language, but they had many thought about the Proof of Concept UI they were presented with. During cycle 2, I created a Figma prototype for the next UI (see \ref{c2:next_ui}). Many of their thoughts about the Proof of Concept UI were things that were already addressed with the new design. This prototype was presented to the advanced focus group, who much preferred it. The advanced focus group had no criticism of the new UI, so it should be implemented as designed for now. 

\section{Implementation}

\subsection{Implementing the new UI}

\subsubsection{Revert Progress Functionality}
We may wish to undo progress. This was functionality designed into the new UI that the advanced focus group specifically mentioned liking. Undoing progress requires that previous \ac{AST} states must be stored. Before now, the most recent \ac{AST} state was stored at a known memory address so any of the functions in the binary could know where to find it. This was done to avoid having to pass the AST to the JavaScript module. If we wanted to store the history of all \ac{AST}s, one approach could be to store all the \ac{AST}s in a pre-allocated memory region in a stack, and then allow the JavaScript module to refer to each of the \ac{AST}s in the history by their stack index. However, pre-allocating enough memory for any potential program execution would be misguided, as it would cause accessibility problems on computers with less memory. Instead, we should employ dynamic allocation. 

The issue with dynamic allocation of memory for the \ac{AST}s as they are added to our history is that we no longer know exactly where they will be located, meaning this information must be stored such that it will not be erased between calls to \ac{WASM} library functions. One method of doing this is passing a pointer to where in memory the AST is located to the JavaScript module so that it can refer to it later, and use library functions on it. At first glance, this sounds like a bad idea, as when pointers are returned from a function for which wasm-bindgen (see \ref{bg:wasm-bindgen}) is used to make a JavaScript binding, the pointer is represented as a JavaScript $number$ type \cite{wasm_bindgen_guide}, which is a double-precision IEEE-754 value\cite{ecma262number}. Storing pointers as floating point values, and then attempting to dereference them, sounds like a recipe for memory mismanagement. However, this is safe because WebAssembly is 32 bit (see \ref{bg:wasm}), and a double precion floating point number has a 52 bit  \cite{ieee754} mantissa meaning it can safely store the 32-bit memory location without issue. 

\subsection{Major Bugfixes}
\begin{itemize}
    \item Typechecker
\end{itemize}

\section{The Intermediate Focus Group: Evaluation and Next Steps}
\label{eval:IFG}
Evaluation:
- They liked explicit match: they liked it more than haskell for learning about how pattern matching works
- Really Really needed light mode
- Horizontal overflow bug