{"rule":"BOTH_AS_WELL_AS","sentence":"^\\QThe interface must be understandable, for both \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q `experts' (lecturers, advanced users) as well as people who have never seen a functional language before.\\E$"}
{"rule":"EN_COMPOUNDS","sentence":"^\\QSFL-explorer takes the form of a functional language (\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q), packaged with two interfaces that allows users to observe the process of evaluation of a term as a series of step by step or multi-step reductions, and control the order that sub-terms are evaluated.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qbreak\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Qbreak\\E$"}
{"rule":"KIND_OF_A","sentence":"^\\QThe `Type of a Type' is its kind \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"SOME_OF_THE","sentence":"^\\QSome of the decisions made, particularly in the implementation of the AST, require an understanding of Rust, especially the memory management model.\\E$"}
{"rule":"ALL_OF_THE","sentence":"^\\Qwasm-pack would compile this to an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q package containing: The WASM binary blob of the compiled rust code A JavaScript file that would load the blob into the browsers' memory, and provides methods that can call the appropriate the methods in the blob A TypeScript file providing the types of all of the packages exported functions.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwhich simply returns its argument.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwhich is isomorphic to the type \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QIn the first match case of valuesToList, we assign the variable \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q when matching the pattern.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QStep Prompt Main Expression Afterwards 0 1 Apply function `fac' to 2 2 [l]Apply function if to (2 <= 1), 1 and (2 * (fac (2 - 1))) 3 Apply inbuilt <= to `2' and `1' 4 Match to pattern `false' 5 [l]Apply function fac to (2 - 1) 6 [l]Apply function if to ((2 - 1) <= 1), 1 and ((2 - 1) * (fac ((2 - 1) - 1))) 7 [l]Apply inbuilt - to 2 and 1\\E$"}
{"rule":"ARROWS","sentence":"^\\QStep Prompt Main Expression Afterwards 0 1 Apply function `fac' to 2 2 [l]Apply function if to (2 <= 1), 1 and (2 * (fac (2 - 1))) 3 Apply inbuilt <= to `2' and `1' 4 Match to pattern `false' 5 [l]Apply function fac to (2 - 1) 6 [l]Apply function if to ((2 - 1) <= 1), 1 and ((2 - 1) * (fac ((2 - 1) - 1))) 7 [l]Apply inbuilt - to 2 and 1\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QSFL Simple Functional Language FP Functional Programming WASM Web ASseMbly CLI Command Line Interface MVP Minimum Viable Product NPM Node Package Manager\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QThis language is type checked, using a modified version of Dunfield and Krishnaswami's bidirectional type checking algorithm \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, modified to include SFL's extended type system.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QFor instance, in the provided `squaresum' example:\\E$"}
{"rule":"MASS_AGREEMENT","sentence":"^\\QThe Type Checker.\\E$"}
{"rule":"THE_TO","sentence":"^\\Qwasm-pack would compile this to an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q package containing: The WASM binary blob of the compiled rust code A JavaScript file that would load the blob into the browsers' memory, and provides methods that can call the appropriate the methods in the blob A TypeScript file providing the types of all of the packages exported functions.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\Qwasm-pack would compile this to an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q package containing: The WASM binary blob of the compiled rust code A JavaScript file that would load the blob into the browsers' memory, and provides methods that can call the appropriate the methods in the blob A TypeScript file providing the types of all of the packages exported functions.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qcreates a type \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q with two data constructors, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"ID_CASING","sentence":"^\\QAfter running the algorithm by hand to convince myself the algorithm works on checking id (\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) against type \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, I modified their algorithm to add my extra types (The inbuilt types \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, as well as the and types) and my extra expression syntax structures (literals, match, pairs).\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qhaving the type alias Card for (Suit, Rank) allows us to very easily, and more readably, create functions on Cards, as well as values with that type.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QParticipants liked the language\\E$"}
